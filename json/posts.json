[
  {
    "idx": 8,
    "title": "Next.js에서 pdf다운하기",
    "summary": "html2canvas와 jspdf 말고 puppeteer를 사용하자!",
    "content": "<div class=\"prose\">\n<p>그동안 PDF다운로드 기능은 html2canvas와 jspdf를 사용해서 클라이언트측에서 구현했지만,\n이번에 사이드 프로젝트를 하면서 서버에서 구현을 하고 싶어 ChatGPT도움을 받아 로직을 구성했습니다.</p>\n<p>기본적인 흐름은 다음과 같은데요</p>\n<ol>\n<li>프론트에서 HTML생성</li>\n<li>생성된 HTML을 서버로 전송</li>\n<li>서버에서 PDF파일 구성 후 프론트로 다시 전달</li>\n</ol>\n<p>위와 같은 흐름을 생각하고 GPT에게 요청하니 puppeteer 라이브러리를 추천해주었습니다.</p>\n<h3>puppeteer란?</h3>\n<p>puppeteer는 Headless Chrome 또는 Chromium 브라우저를 제어하기 위한 Node.js 라이브러리로 구글이 만들었습니다.\n주로 웹 스크래핑 혹은 테스트에 사용한다고 하는데 pdf생성해도 딱 맞아서 이번에 사용해보기로 결정했습니다.</p>\n<h3>클라이언트 로직 구성</h3>\n<p>클라이언트 측 로직은 간단한데요,\npdf로 만들기 원하는 HTML을 서버로 전송 후,\nresponse를 a태그를 생성해서 다운로르 하면 끝입니다.</p>\n<pre><code>const handleDownloadPDF = async () =&gt; {\n    const input = document.getElementById(\"pdf-content\");\n    if (input) {\n      const htmlContent = input.outerHTML;\n\n      const response = await fetch(\"/api/pdf\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ htmlContent }),\n      });\n\n      if (response.ok) {\n        const blob = await response.blob();\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"download.pdf\";\n        document.body.appendChild(a);\n        a.click();\n        a.remove();\n      } else {\n        console.error(\"Error generating PDF\");\n      }\n    }\n  };\n</code></pre>\n<h3>서버 로직 구성</h3>\n<p>서버는 조금 복잡합니다.\n(사실 next.js 15버전으로 처음 구현하느라 공식문서를 참고하는 시간이 더 길었네요)</p>\n<p>전체코드는 아래와 같습니다.</p>\n<pre><code>import { NextRequest, NextResponse } from \"next/server\";\nimport puppeteer from \"puppeteer\";\n\n// 응답을 캐싱하지 않고 매번 재응답\nexport const dynamic = \"force-static\";\n\nexport async function POST(req: NextRequest) {\n  const { htmlContent } = await req.json();\n  if (!htmlContent) {\n    return NextResponse.json(\n      { message: \"HTML content is required\" },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const browser = await puppeteer.launch({\n      headless: true,\n      args: [\"--no-sandbox\", \"--disable-setuid-sandbox\"],\n    });\n    const page = await browser.newPage();\n\n    // HTML 콘텐츠 설정\n    await page.setContent(htmlContent, { waitUntil: \"load\" });\n\n    // PDF 생성\n    const pdfBuffer = await page.pdf({\n      format: \"A4\",\n      printBackground: true,\n      margin: { top: \"20mm\", bottom: \"20mm\", left: \"10mm\", right: \"10mm\" },\n    });\n\n    await browser.close();\n\n    // PDF 반환\n    const response = new NextResponse(pdfBuffer, {\n      headers: {\n        \"Content-Type\": \"application/pdf\",\n        \"Content-Disposition\": \"attachment; filename=generated.pdf\",\n      },\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"Error generating PDF:\", error);\n    return NextResponse.json(\n      { message: \"Failed to generate PDF\" },\n      { status: 500 }\n    );\n  }\n}\n</code></pre>\n<p>위 코드는 언핏보면 잘 동작하는 것 같지만 두가지 문제가 있었어요</p>\n<h2>이미지가 안 보이네?</h2>\n<p>위 코드를 실행하니 이미지가 모두 깨져서 출력되는 문제가 발생했습니다.\n우선 프론트 로직 구조상 이미지는 모두 내부파일을 사용하고 있었습니다.\n그래서 경로는 \"/icons/testImage.svg\"와 같이 상대경로 되어있었죠.\n여기서 문제가 발생했습니다.</p>\n<p><code>&lt;img src=\"/techstack/back/nestjs.svg\"&gt;</code>\n서버로 넘겨주는 HTML의 img태그의 src경로가 상대경로로 되어있어 이미지 인식을 못했던겁니다.\n즉, 서버에서 이미지 경로를 절대경로로 변경해야 하는거죠</p>\n<p>htmlContent변수를 let으로 수정하고\n다음과 같이 상대경로를 절대경로로 변경해주면 됩니다.</p>\n<pre><code>  const baseUrl = \"http://서버주소\"; //\n  htmlContent = htmlContent.replace(/src=\"\\/(.*?)\"/g, `src=\"${baseUrl}/$1\"`);\n</code></pre>\n<h2>CSS와 폰트 어디갔니?</h2>\n<p>해당 프로젝트는 tailwind를 사용하고 있었는데요.\n이 때문에 pdf를 출력하면 CSS가 모두 초기화되는 현상이 나타났습니다.\n서버에선 tailwind가 없어서 className을 인식하지 못해서 당연한 현상이였죠</p>\n<p>수정은 간단합니다.\ntawilwind CDN을 HTML에 추가해주고,\n원하는 폰트 또한 스타일에 추가시켜주면 됩니다.</p>\n<pre><code>// Tailwind CDN 추가\n  const tailwindCDN = `\n   &lt;link href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css\" rel=\"stylesheet\"&gt;\n   &lt;link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap\" rel=\"stylesheet\"&gt;\n   &lt;style&gt;\n     body { font-family: 'Inter', sans-serif; }\n   &lt;/style&gt;\n `;\n\n  htmlContent = `\n   &lt;!DOCTYPE html&gt;\n   &lt;html lang=\"en\"&gt;\n     &lt;head&gt;\n       &lt;meta charset=\"UTF-8\"&gt;\n       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n       ${tailwindCDN}\n     &lt;/head&gt;\n     &lt;body&gt;\n       ${htmlContent}\n     &lt;/body&gt;\n   &lt;/html&gt;\n `;\n</code></pre>\n<p>이로써 서버측에서 pdf를 생성하는 로직을 구현 완료했습니다.\n아직 다듬을 부분이 더 있지만, 이는 추후 다시 수정해봐야겠네요.</p>\n</div>",
    "date": "2025-01-16"
  },
  {
    "idx": 7,
    "title": "canvas.toBlob이 IOS에서 null을 반환 받는 경우",
    "summary": "어렵고 어려운 크로스 브라우징🤣",
    "content": "<div class=\"prose\">\n<p>회사에서 react-easy-crop 라이브러리와 canvas API를 사용하다가 IOS에서만 zoom이 1이하인 경우에 canvas.toBlob이 null을 반환받는 현상을 발견했다.</p>\n<p>이런저런 방법을 찾아보다 gpt 친구에게 물어보니 ios에선 메모리 제한에 걸려  null을 반환받을 수 있다는 답변을 받고 캔버스 크기를 확인해 보니,\n특정 zoom 이하인 경우에는 캔버스 크기가 무지막지하게 커져있었다.</p>\n<blockquote>\n<p><strong>GPT답변</strong>\niOS에서 매우 높은 해상도나 대형 캔버스를 사용할 경우 메모리 제한으로 인해 빈 이미지를 생성할 수 있습니다. 이를 해결하려면 캔버스 크기를 줄이거나, 이미지 해상도를 낮추어 메모리 사용량을 줄이는 것이 좋습니다.</p>\n</blockquote>\n<p>해결법은 상당히 간단하다.\n이미지 해상도를 낮추거나 캔버스 크기를 줄이면된다.\n우리 서비스는 이미지 해상도가 중요하니\n캔버스 크기를 zoom만큼 줄이는 방법으로 수정했다.</p>\n<pre><code>const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\nnewImage.src = imagePath;\nnewImage.onload = () =&gt; {\n  const scalefactor = Math.min(zoom, 1);\n  \n  canvas.width = width * scalefactor;\n  canvas.height = height * scalefactor;\n  \n  ctx.scale(scalefactor, scalefactor);\n  ctx.drawImage(newImage, 0, 0);\n\n  canvas.toBlob((blob) =&gt; {\n    ...로직\n  }, 'image/png');\n};\n</code></pre>\n</div>",
    "date": "2024-11-12"
  },
  {
    "idx": 6,
    "title": "visual studio code 터미널 프로필 꾸미기",
    "summary": "터미널 꾸미기 어렵지~ 않아요",
    "content": "<div class=\"prose\">\n<h1>이제는 테스트 코드를 작성할 때</h1>\n<p>작년 5월 이직 후, 회사에서 담당한 프로젝트를 지속적으로 리팩토링 및 기능 추가를 진행하고 있었다.</p>\n<p>사실 개발을 진행하면서 테스트코드 없이 로직검증을 위해 생각보다 많은 시간이 소요되는걸 느끼고 테스트 코드의 필요성을 깨달았다.\n(특정시간에 오픈되는 UI, 가격계산로직 등등... 테스트코드 없이 검증하려니 비효율적으로 낭비되는 시간과 노력이 많이 발견됨)</p>\n<p>그러다 다른 팀의 신규 프로젝트 준비로 잠시 여유가 생겨 미루고 미뤄뒀던 테스트 코드를 도입하기로 결정했다.</p>\n\n<h1>Why Vitest</h1>\n<p>처음엔 jest를 사용하려 했지만 최종적으론 vitest를 사용하기로 했다.\njest에 비해 초기설정도 간단하며 테스트 속도도 더 빠른 것으로 판단되어 vitest를 사용하지 않을 이유가 없었다.</p>\n<p>또한, <a href=\"https://www.npmjs.com/package/@vitest/ui\">vitest/ui</a> 라이브러리를 통한 GUI도 깔끔하여 개발 효율이 더 증가해서 만족스러웠다.</p>\n<p>비록 아직 Vitest 사용자가 많지 않아 레퍼런스가 적지만,\njest와 90% 이상(주관적 수치입니다)유사하여 막히는 부분이 있으면 ChatGPT의 도움으로도 충분히 커버가 가능하다.</p>\n\n<h1>Test파일은 어디에 두어야 하나</h1>\n<p>처음 테스트 코드를 작성하면서 가장 큰 고민은 테스트 코드의 위치였다.\n처음엔 __tests__ 폴더를 생성하여 하위 폴더에 작성하였다.</p>\n<p>그러나 이 방식은 테스트 코드와 파일들의 위치가 너무 멀어 매번 스크롤을 해주고,\n원하는 테스트 파일을 찾는데 시간도 걸리는 문제도 있다는 단점이 있었다.</p>\n<p>결국 개발 효율을 위해 테스트 관련 유틸 및 설정파일은 __tests__ 폴더에 두고, 나머지 파일들은 테스트대상 파일 바로 아래에 두는 방식으로 변경했다.</p>\n\n<h1>트러블슈팅</h1>\n<h2>next/Image src문제</h2>\n<p>next/image컴포넌트의 src는 보통 \"/_next/image?url=~~\"와 같은 형태로 구성된다.</p>\n<p>만약 이미지 경로가 \"testImage.com\"이라고 가정하면\nnext/image를 통한 src는 \"/_next/image?url=testImage.com&w=640&q=50\"과 같은 형태이므로\n<code>expect().toHaveAttribute('src',\"testImage.com\")</code>는 틀린 테스트케이스가 된다.</p>\n<p>이 문제는 next/image컴포넌트 자체를 mocking하여 일반 img태그를 변환시키는 방법으로 해결했다.</p>\n<pre><code>import { vi } from 'vitest';\n\nconst mockNextImage = () => {\n  vi.mock('next/image', () => ({\n    __esModule: true,\n    default: (\n      props: React.DetailedHTMLProps<\n        React.ImgHTMLAttributes<HTMLImageElement>,\n        HTMLImageElement\n      >,\n    ) => {\n      return <img alt={props.alt} {...props} />;\n    },\n  }));\n};\n\nexport { mockNextImage };\n</code></pre>\n\n<h2>Next.js Dynamic Import</h2>\n<p>특정 컴포넌트는 nextjs에서 제공하는 dynamic을 사용해서 import하고 있었다.\n이러한 컴포넌트들은 vitest 테스트 환경에선 load되지 않는 문제가 있다.</p>\n<p>해당 문제는 next/dynamic자체를 mocking하여 해결 가능하다.</p>\n<pre><code>vi.mock('next/dynamic', async () => {\n  const dynamicModule: any = await vi.importActual('next/dynamic');\n  return {\n    default: (loader: any) => {\n      const dynamicActualComp = dynamicModule.default;\n      const RequiredComponent = dynamicActualComp(() =>\n        loader().then((mod: any) => mod.default || mod),\n      );\n\n      // for debugging\n      if (RequiredComponent?.render?.displayName) {\n        RequiredComponent.render.displayName = loader.toString();\n      }\n\n      RequiredComponent.preload\n        ? RequiredComponent.preload()\n        : RequiredComponent.render.preload();\n\n      return RequiredComponent;\n    },\n  };\n});\n</code></pre>\n</div>",
    "date": "2024-03-04"
  },
  {
    "idx": 5,
    "title": "사내 테스트코드 도입기",
    "summary": "나도 드디어 도전한다 TDD!",
    "content": "<div class=\"prose\">\n<h1>이제는 테스트 코드를 작성할 때</h1>\n<p>작년 5월 이직 후, 회사에서 담당한 프로젝트를 지속적으로 리팩토링 및 기능 추가를 진행하고 있었다.</p>\n<p>사실 개발을 진행하면서 테스트코드 없이 로직검증을 위해 생각보다 많은 시간이 소요되는걸 느끼고 테스트 코드의 필요성을 깨달았다.\n(특정시간에 오픈되는 UI, 가격계산로직 등등... 테스트코드 없이 검증하려니 비효율적으로 낭비되는 시간과 노력이 많이 발견됨)</p>\n<p>그러다 다른 팀의 신규 프로젝트 준비로 잠시 여유가 생겨 미루고 미뤄뒀던 테스트 코드를 도입하기로 결정했다.</p>\n\n<h1>Why Vitest</h1>\n<p>처음엔 jest를 사용하려 했지만 최종적으론 vitest를 사용하기로 했다.\njest에 비해 초기설정도 간단하며 테스트 속도도 더 빠른 것으로 판단되어 vitest를 사용하지 않을 이유가 없었다.</p>\n<p>또한, <a href=\"https://www.npmjs.com/package/@vitest/ui\">vitest/ui</a> 라이브러리를 통한 GUI도 깔끔하여 개발 효율이 더 증가해서 만족스러웠다.</p>\n<p>비록 아직 Vitest 사용자가 많지 않아 레퍼런스가 적지만,\njest와 90% 이상(주관적 수치입니다)유사하여 막히는 부분이 있으면 ChatGPT의 도움으로도 충분히 커버가 가능하다.</p>\n\n<h1>Test파일은 어디에 두어야 하나</h1>\n<p>처음 테스트 코드를 작성하면서 가장 큰 고민은 테스트 코드의 위치였다.\n처음엔 __tests__ 폴더를 생성하여 하위 폴더에 작성하였다.</p>\n<p>그러나 이 방식은 테스트 코드와 파일들의 위치가 너무 멀어 매번 스크롤을 해주고,\n원하는 테스트 파일을 찾는데 시간도 걸리는 문제도 있다는 단점이 있었다.</p>\n<p>결국 개발 효율을 위해 테스트 관련 유틸 및 설정파일은 __tests__ 폴더에 두고, 나머지 파일들은 테스트대상 파일 바로 아래에 두는 방식으로 변경했다.</p>\n\n<h1>트러블슈팅</h1>\n<h2>next/Image src문제</h2>\n<p>next/image컴포넌트의 src는 보통 \"/_next/image?url=~~\"와 같은 형태로 구성된다.</p>\n<p>만약 이미지 경로가 \"testImage.com\"이라고 가정하면\nnext/image를 통한 src는 \"/_next/image?url=testImage.com&w=640&q=50\"과 같은 형태이므로\n<code>expect().toHaveAttribute('src',\"testImage.com\")</code>는 틀린 테스트케이스가 된다.</p>\n<p>이 문제는 next/image컴포넌트 자체를 mocking하여 일반 img태그를 변환시키는 방법으로 해결했다.</p>\n<pre><code>import { vi } from 'vitest';\n\nconst mockNextImage = () => {\n  vi.mock('next/image', () => ({\n    __esModule: true,\n    default: (\n      props: React.DetailedHTMLProps<\n        React.ImgHTMLAttributes<HTMLImageElement>,\n        HTMLImageElement\n      >,\n    ) => {\n      return <img alt={props.alt} {...props} />;\n    },\n  }));\n};\n\nexport { mockNextImage };\n</code></pre>\n\n<h2>Next.js Dynamic Import</h2>\n<p>특정 컴포넌트는 nextjs에서 제공하는 dynamic을 사용해서 import하고 있었다.\n이러한 컴포넌트들은 vitest 테스트 환경에선 load되지 않는 문제가 있다.</p>\n<p>해당 문제는 next/dynamic자체를 mocking하여 해결 가능하다.</p>\n<pre><code>vi.mock('next/dynamic', async () => {\n  const dynamicModule: any = await vi.importActual('next/dynamic');\n  return {\n    default: (loader: any) => {\n      const dynamicActualComp = dynamicModule.default;\n      const RequiredComponent = dynamicActualComp(() =>\n        loader().then((mod: any) => mod.default || mod),\n      );\n\n      // for debugging\n      if (RequiredComponent?.render?.displayName) {\n        RequiredComponent.render.displayName = loader.toString();\n      }\n\n      RequiredComponent.preload\n        ? RequiredComponent.preload()\n        : RequiredComponent.render.preload();\n\n      return RequiredComponent;\n    },\n  };\n});\n</code></pre>\n</div>",
    "date": "2024-01-05"
  },
  {
    "idx": 4,
    "title": "HEIF형식 이미지 업로드 대응",
    "summary": "최신 이미지 포맷인 HEIF를 아시나요?",
    "content": "<div class=\"prose\"><h1>어느날...</h1>\n<p>어느날 heic(heif) 이미지 파일이 업로드가 되지 않는다는 문의가 왔다.\nheif형식이 무엇인지 찾아보니 고효율 이미지 파일 포맷(High Efficiency Image Format)으로 동일한 크기의 jpeg보다 2배나 더 많은 정보를 저장할 수 있으므로 화질이 더 좋다고 한다.</p>\n<p>그러나 2023년 현재에도 아직 호환성이 떨어지며 웹브라우저에서는 지원하지 않고 있다.\nIOS의 경우에는 heic파일을 업로드할 때 자체적으로 jpg로 변환시켜주므로 큰 문제는 없지만,\nAOS및 브러우저에서는 직접 jpg로 변환하는 로직을 구성해줘야 heic이미지 업로드가 대응된다.</p>\n<p>따라서 heif형식을 jpg로 변경하는 로직을 구성해서 해당 이슈를 해결하기로 결정했다.</p>\n<h1>heic2any 라이브러리 도입</h1>\n<p>처음에는 단순히 jpg타입을 지정해서 blob으로 변환 후 다시 파일로 만들면 되지 않을까 싶었지만 확장자만 변경되고 문서유형은 변경되지 않아서 실패했다.</p>\n<pre><code>const blob = new Blob([innerFile[1]], {\n  type: 'image/jpeg',\n});\n\nconst heifToPngFile = new File(\n  [blob],\n  innerFile[1].name\n    .replaceAll('.heif', '.jpg')\n    .replaceAll('.heic', '.jpg')\n    .replaceAll('.HEIC', '.jpg')\n    .replaceAll('.HEIF', '.jpg'),\n  {\n    type: 'image/jpeg',\n  },\n);\n</code></pre>\n<p>방법을 찾다가 CTO님이 추천해주신 heic2any를 사용하기로 결정했다\n구글링 결과, 해당 라이브러리를 사용해서 heif파일을 변환하는 사례가 몇몇 있어서 해당 사례들을 참고해서 로직을 구현했다.</p>\n<pre><code>const blob = new Blob([files[0]]);\nconst transBlob = await heic2any({\n  blob,\n  quality: 0.1,\n  toType: 'image/jpeg',\n});\nconst trnasFile = new File(\n  [transBlob],\n  files[0].name\n    .replaceAll('.heif', '.jpg')\n    .replaceAll('.heic', '.jpg')\n    .replaceAll('.HEIC', '.jpg')\n    .replaceAll('.HEIF', '.jpg'),\n  {\n    type: 'image/jpeg',\n    lastModified: new Date().getTime(),\n  },\n);\n</code></pre>\n<p>위의 로직을 사용해서 테스트해 보니 잘 작동하여 안심을 했지만....\n뜻밖의 변수가 발생했다.</p>\n<h1>AOS버전에 따른 차이점</h1>\n<p>회사에서 안드로이드폰으로 테스트 중, 안드로이드 8 버전에서는 이미지가 업로드 되지 않는 문제가 발견되어 디버깅을 진행하고 문제점을 발견했다.</p>\n<p>특정 안드로이드 버전에서는 Heif 형식을 지원하지 않으므로 해당 파일을 업로드할 때, 파일의 타입이 정해지지 않고 비어있는 상태로 업로드되어 서버 측에서 해당 파일 업로드를 하지 않았던 것이다.</p>\n<p>안드로이드 공식 홈페이지에 따르면 안드로이드 10버전부터 Heif 형식을 지원해준다고 한다. <a href=\"https://source.android.com/docs/core/camera/heif?hl=ko\">안드로이드 공식 홈페이지</a></p>\n<p>따라서 기존 로직에 안드로이드 버전10버전 미만에서는 blob으로 변경후, 타입을 지정해주는 방법으로 문제를 해결했다.</p>\n<pre><code>const userAgent = navigator.userAgent.toLowerCase();\nconst androidIndex = userAgent.indexOf('android');\nconst androidVer = Number(\n  userAgent\n    .substring(androidIndex + 8)\n    .split(';')[0]\n    .split('.')[0],\n);\n\nif (androidVer &lt; 10) {\n  const blob = new Blob([innerFile[1]], {\n    type: 'image/jpeg',\n  });\n\n  const heifToPngFile = new File(\n    [blob],\n    innerFile[1].name\n      .replaceAll('.heif', '.jpg')\n      .replaceAll('.heic', '.jpg')\n      .replaceAll('.HEIC', '.jpg')\n      .replaceAll('.HEIF', '.jpg'),\n    {\n      type: 'image/jpeg',\n    },\n  );\n}\n</code></pre>\n<p>#개선할 점\nheic2any라이브러리를 사용해서 문제를 해결할 수 있었지만....\n해당 라이브러리 번들 사이즈를 확인하니 너무 무지막지한 용량을 가지고 있었다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yung315/post/2cbc8bd8-dfc2-48f8-8013-e936f9f650b2/image.png\"></p>\n<p>이러한 사이즈 문제는 깃헙 이슈에도 이미 올라와 있었는데,\n개발자의 답변으로는 heif 변환시 사용하는 libheif 라이브러리 용량 자체가 크므로 해결방법이 없다고한다. <a href=\"https://github.com/alexcorvi/heic2any/issues/35\">깃헙 이슈</a></p>\n<p>결국 라이브러리를 사용하지않거나 다른 라이브러리가 있는지 찾을 필요가 있어보인다.</p></div>",
    "date": "2023-10-10"
  },
  {
    "idx": 3,
    "title": "ReactDOMClient.hydrateRoot사용 시, hydration 오류",
    "summary": "next.js 및 react에서 자주 발생하는 hydration오류, 넌 뭐니?",
    "content": "<div class=\"prose\"><p>회사에서 담당한 프로젝트를 리팩토링 하던 중, dangerouslySetInnerHTML을 사용한 컴포넌트에서 hydration 오류가 발생하여 이를 해결한 경험을 남겨본다.</p>\n<h2>우선, hydration이란?</h2>\n<p>hydration은 서버에서 만들어진 HTML이 클라이어트단으로 넘어온 뒤,\nHTML과 JS를 결합하는 과정이라 생각하면 된다.\n이 과정에서 서버에서 생성된 HTML과 브라우저에서 처음 렌더링 되는 HTML은 동일해야하며, 만약 동일하지 않다면 hydration오류가 발생한다.</p>\n<h2>그래서 문제가 뭔데?</h2>\n<p>우선 해당 컴포넌트는 아래의 역할을 하고 있다.</p>\n<blockquote>\n<ol>\n<li>Admin에서 HTML을 문자열 형태로 전송</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>해당 HTML중 dataset.type이 설정된 태그는 클라이언트측에서 CSS수정</li>\n<li>수정된 CSS를 포함해서 dangerouslySetInnerHTML을 사용하여 렌더링</li>\n</ol>\n<p>기존의 로직은 아래와 같이 ReactDOMClient.hydrateRoot을 사용하고 있었다.</p>\n<pre><code>useEffect(()=&gt;{\n\tconst target: NodeListOf&lt;HTMLElement&gt; = document.querySelectorAll('.target_class_name');\n    \n    target.forEach((dom) =&gt; {\n      if (dom.dataset.type === '특정타입') {\n        ReactDOMClient.hydrateRoot(\n          dom,\n        \t\t&lt;CSSModifyComponent /&gt;\n        );\n\t}\n},[])\n</code></pre>\n<p>해당 코드에서 hydration오류가 발생한 이유는 ReactDOMClient.hydrateRoot을 사용했기 때문이다.</p>\n<p>React에서 설명하는 ReactDOMClient.hydrateRoot는 다음과 같다</p>\n<blockquote>\n<p>createRoot()과 동일하지만, HTML 컨텐츠가 ReactDOMServer로 렌더링된 컨테이너를 hydrate 할 때 사용합니다. React는 기존 마크업에 이벤트 리스너를 연결하려 시도할 것입니다.</p>\n</blockquote>\n<p>즉, hydrateRoot는 새로 렌더링된 결과물을 만드는것이 아닌 미리 만들어진 결과물에 이벤트 리스너만 부착하는것이다.</p>\n<p>따라서 새로운 HTML을 렌더링하기 위해서 hydrateRoot를 사용하는것은 적절하지 않으므로 오류가 발생했던것이다.</p>\n<p>해당 오류를 해결법은 간단한데,\nReactDOMClient.createRoot를 사용하여 클라이언트측에서 HTML을 다시 구성해주면 된다.</p>\n<pre><code>useEffect(()=&gt;{\n\tconst target: NodeListOf&lt;HTMLElement&gt; = document.querySelectorAll('.target_class_name');\n    \n    target.forEach((dom) =&gt; {\n      if (dom.dataset.type === '특정타입') {\n      const targetDom = ReactDOMClient.createRoot(dom);\n      targetDom.render(\n        ReactDOMClient.hydrateRoot(\n          dom,\n        \t\t&lt;CSSModifyComponent /&gt;\n        ))\n\t}\n},[])\n</code></pre></div>",
    "date": "2023-08-10"
  },
  {
    "idx": 2,
    "title": "Git - remote: The project you were looking for could not be found or you don't have permission to view it. ",
    "summary": "원격저장소에서 발생하는 Git 오류룰 해결 과정",
    "content": "<div class=\"prose\"><p>회사에서 운영중인 프로젝트를 급하게 수정 후 배포할 일이 생겼다.\n작업을 다 끝내고 push까지 완료해서 일이 끝났다고 생각했지만 갑자기 뜬 아래의 gitlab CI/CD오류...</p>\n<blockquote>\n<p>remote: The project you were looking for could not be found or you don't have permission to view it.\nfatal: repository '저장소주소' not found</p>\n</blockquote>\n<p>처음엔 로컬환경 문제인가 싶어서 급하게 로컬 git origin주소를 변경했지만 해결 실패...!\n이후 gitlab runner문제라 생각되어 runner재등록을 진행했지만 또 실패 !</p>\n<p>몇시간 고민 후 해결방법을 찾았는데 원인은 생각보다 간단했다.</p>\n<p>바로 ec2 git origin을 변경해주면 되는것 !\n(배포환경은 ec2 + gilab CI/CD)</p>\n<p>ec2로 접속후 <strong>git remote set-url origin</strong> 명령어를 사용하여 수정해주니 문제해결 !</p>\n<pre><code>수정 전 git origin\nhttps://gitlab.com/프로젝트/프로젝트_명.git\n\n수정 후 git origin\nhttps://깃랩아이디:비밀번호@gitlab.com/프로젝트/프로젝트명.git\n</code></pre></div>",
    "date": "2023-07-20"
  },
  {
    "idx": 1,
    "title": "next/image - Error handling",
    "summary": "next/image 컴포넌트로 이미지 에러를 핸들링해 보자!",
    "content": "<div class=\"prose\"><p>회사에서 리펙토링을 진행하던 중, 아래의 이슈사항을 발견했다.</p>\n<blockquote>\n<ol>\n<li>API 호출로 이미지 경로를 받아오고, 해당 이미지는 next/image로 렌더링</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>이미지 경로가 null인 경우에는 defaultImage를 렌더링</li>\n<li>이미지 경로를 받아오지만, 해당 경로의 이미지에 문제가 있는 경우에는 defaultImage를 보여주지 못하는 문제가 발생 !!</li>\n</ol>\n<pre><code>&lt;Image \n    alt={\"이미지\"} \n    src={imgUrl ? imgUrl : DEFAULT_IMG_URL} \n    width={width} \n    height={height} \n/&gt;\n</code></pre>\n<p>기존 코드는 위와 같았다. 기존 코드는 imgUrl이 null이 아닌 경우만 체크하고 있기 때문에 이미지 경로가 문제가 있는 경우의 예외처리를 진행하지 못하고 있었다.</p>\n<p>예를 들어 서버에서 보내준 \"admin/img1\" 이미지가 문제가 발생해 404를 반환받는 경우, 기존 코드는 imgUrl이 null이 아니므로 defaultImg가 렌더링되지 않는 것이다.</p>\n<p>위와 같은 문제를 방지하기 위해서 next/image의 onError를 활용해 커스텀 컴포넌트를 생성하였다.</p>\n<pre><code>interface ImageProps {\n    alt: string;\n    src: string;\n    width: number;\n    height: number;\n}\n\nexport default function ImageWithFallback({ alt, src, height, width }: ImageProps) {\n    const [isImgError, setIsImgError] = useState&lt;boolean&gt;(false);\n\n    return (\n        &lt;Image \n            alt={alt} \n            src={isImgError ? DEFAULT_PROFILE_IMG_URL : src} \n            width={width} \n            height={height} \n            onError={() => setIsImgError(true)} \n        /&gt;\n    );\n}\n</code></pre>\n<p>위와 같이 onError를 활용해 이미지 load에 실패하는 경우에는 isImgError가 true로 변경되면서 defaultImg를 보여주는 방식으로 리팩토링을 진행했다.</p></div>",
    "date": "2023-07-03"
  }
]
