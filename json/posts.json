[
  {
    "idx": 12,
    "title": "event.target과 event.currentTarget의 차이",
    "summary": "event.target과 event.currentTarget의 차이를 알아보자!",
    "content": "<div class=\"prose\"><p>최근 면접에서 <code>event.target</code>과 <code>event.currentTarget</code>의 차이를 답변하는 질문이 있었습니다. 부끄럽게도 둘의 차이점을 반대로 얘기하는 대참사가 벌어졌죠. 그래서 저와 같은 분들이 없도록 포스트를 작성해보려고 합니다😂</p>\n<h1>이벤트 위임</h1>\n<p>둘의 차이점을 알기 전에 우선 JS의 이벤트 위임을 알아야 합니다. 이벤트 위임은 이벤트 리스너를 부모 요소에 등록하여, 하위 요소에서 발생하는 이벤트를 부모가 감지하고 처리하는 방법입니다.</p>\n<p>이는 JS의 버블링 때문에 발생하는데, 버블링이란 자식 요소에서 발생하는 이벤트가 부모 요소로 전파되는 현상입니다. (그 반대는 캡처링입니다)</p>\n<p>이벤트 위임은 주로 동적으로 생성되는 요소를 관리하기 위해 사용하죠.</p>\n<pre><code>&lt;ul id=\"parent\"&gt;\n  &lt;li&gt;Item 1&lt;/li&gt;\n  &lt;li&gt;Item 2&lt;/li&gt;\n  &lt;li&gt;Item 3&lt;/li&gt;\n&lt;/ul&gt;\n&lt;button id=\"addItem\"&gt;Add Item&lt;/button&gt;\n\n&lt;script&gt;\n  const parent = document.getElementById(\"parent\");\n  const addItem = document.getElementById(\"addItem\");\n\n  // ✅ 이벤트 위임: 부모 요소에서 클릭 이벤트 감지\n  parent.addEventListener(\"click\", (event) => {\n    if (event.target.tagName === \"LI\") {\n      console.log(`Clicked: ${event.target.textContent}`);\n    }\n  });\n\n  // ✅ 동적으로 리스트 추가\n  addItem.addEventListener(\"click\", () => {\n    const newItem = document.createElement(\"li\");\n    newItem.textContent = `Item ${parent.children.length + 1}`;\n    parent.appendChild(newItem);\n  });\n&lt;/script&gt;\n</code></pre>\n<h1>target과 currentTarget의 차이점</h1>\n<p><code>target</code>은 이벤트가 실제로 발생한 요소이며, <code>currentTarget</code>은 이벤트가 등록된 요소입니다.</p>\n<p>위의 코드에서 이벤트가 실행되면 <code>target</code>은 <code>li</code>이며, <code>currentTarget</code>은 이벤트가 등록된 <code>ul</code>이 되는 거죠.</p>\n<h1>React에선 왜 currentTarget을 사용할까?</h1>\n<p>React와 TS를 사용한다면 주로 <code>currentTarget</code>을 사용합니다. 그러면 왜 <code>currentTarget</code>을 사용할까요?</p>\n<p>가장 큰 이유는 타입의 안정성과 React의 SyntheticEvent(합성 이벤트) 구조 때문입니다.</p>\n<p>우선 TS에서는 <code>event.target</code>과 <code>event.currentTarget</code>의 타입이 다릅니다.</p>\n<pre><code>&lt;button onClick={handleClick}&gt;\n    &lt;span&gt;Click Me&lt;/span&gt;\n&lt;/button&gt;\n\nconst handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {\n  console.log(event.currentTarget); // ✅ HTMLButtonElement (안전함)\n};\n\nconst handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {\n  console.log(event.target); // ❌ TypeScript 오류 발생 가능\n};\n</code></pre>\n<p>위 코드에서 <code>currentTarget</code>은 이벤트가 발생한 위치와 상관없이 <code>currentTarget</code>의 타입은 항상 <code>HTMLButtonElement</code>이므로 TypeScript에서 안전합니다.</p>\n<p>만약 <code>span</code>을 클릭하는 경우, <code>target</code>은 <code>span</code>이 되므로 타입 오류가 발생할 가능성이 있습니다.</p>\n<p>두 번째 이유로는 React의 이벤트 동작 방식에 있습니다. React에서는 이벤트 핸들러가 실행된 후 SyntheticEvent 객체를 초기화하여 메모리를 절약합니다.</p>\n<p>평소에는 이런 동작이 문제가 되지 않지만, 만약 비동기 작업이 추가되면 문제가 발생할 가능성이 생깁니다.</p>\n<pre><code>const handleClick = () => {\n  setTimeout(() => {\n    console.log(event.target); \n    // 🚨 SyntheticEvent가 풀링되었으므로, event.target이 null이 될 가능성이 있음\n  }, 1000);\n};\n</code></pre>\n<p>위 코드에서 <code>handleClick</code> 함수가 종료되면서, React는 SyntheticEvent를 풀링하여 메모리를 정리합니다. 메모리 정리가 끝난 뒤 <code>setTimeout</code>이 실행되면서 <code>event.target</code>을 참조하려 하지만, 이미 <code>null</code>이 되어 있어 예상치 못한 사이드 이펙트가 발생할 가능성이 있습니다.</p>\n<p>이를 막기 위해서는 <code>target</code>을 미리 저장하거나 <code>currentTarget</code>을 사용하여 이벤트 핸들러가 바인딩된 요소를 가리키는 방법으로 해결할 수 있습니다.</p>\n<pre><code>const handleClick = (event: React.MouseEvent) => {\n  const target = event.target;\n  setTimeout(() => {\n    console.log(target); \n  }, 1000);\n};\n</code></pre>\n<p>이제는 여러분도 면접에서도 헷갈리지 않고, 확실하게 답변할 수 있을 것 같습니다!</p></div>",
    "date": "2025-02-12"
  },
  {
    "idx": 11,
    "title": "클로저와 함께하는 디바운스 & 쓰로틀링",
    "summary": "디바운스와 쓰로틀링을 클로저로 이해해 보자!",
    "content": "<div class=\"prose\"><p>프론트엔드 면접을 준비하면 클로저, 디바운스, 쓰로틀링은 자주 접하게 됩니다. 꼭 면접 준비가 아니더라도 개발을 하다 보면 위 개념들은 필수적으로 접하게 되는데요. 디바운스와 쓰로틀링에 클로저가 사용된다는 걸 아셨나요? 전 부끄럽게도 최근 lodash 라이브러리를 직접 구현하던 도중 이 사실을 깨달았습니다.</p>\n<h2>1. 클로저</h2>\n<p>클로저는 함수가 나중에 호출되더라도 선언 당시의 외부 변수나 상태를 접근할 수 있는 기능입니다. 즉, 외부 변수나 상태는 내부 함수가 참조하고 있는 동안에는 메모리에 남아 있습니다.</p>\n<pre><code>function createCounter() {\n  let count = 0;  // 외부 함수의 지역 변수\n\n  return () => {\n    count += 1;  // 외부 변수 count에 접근\n    console.log(`Count: ${count}`);\n  };\n}\n\nconst counter = createCounter();  \n\ncounter();  // Count: 1\ncounter();  // Count: 2\ncounter();  // Count: 3\n</code></pre>\n<p>위 코드에서 <code>counter</code> 변수가 생성되면서 <code>createCounter()</code> 함수는 종료됐지만, 내부 함수가 <code>count</code>를 참조하고 있기 때문에 <code>count</code>는 가비지 컬렉션 대상이 아닙니다.</p>\n<h2>2. 디바운스</h2>\n<p>디바운스는 동일 이벤트가 여러 번 발생하더라도 일정 시간이 지난 후에 마지막 이벤트만 실행하는 기능입니다.</p>\n<pre><code>const debounce = (func: Function, delay: number) => {\n  let timer: NodeJS.Timeout;\n\n  return (...args: any[]) => {\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => func(...args), delay);\n  };\n};\n</code></pre>\n<p><code>debounce</code> 함수의 매개변수로 받은 <code>func</code>와 <code>delay</code>를 <code>setTimeout</code>에 등록하고, 이를 <code>timer</code> 변수에 할당합니다. 만약 <code>delay</code> 전에 이벤트가 또 발생하면 기존의 <code>timeout</code>은 <code>clear</code>하고 다시 등록하는 거죠.</p>\n<p>그런데 위 코드 구조 어디서 많이 본 구조 같지 않나요?</p>\n<p>네! 우리가 위에서 봤던 클로저 예시와 동일합니다. <code>debounce</code> 함수가 실행된 후 내부 함수가 <code>timer</code> 변수를 계속 참조하고 있는 거죠.</p>\n<h2>3. 쓰로틀링</h2>\n<p>쓰로틀링은 이벤트 발생 후 일정 시간 동안 동일 이벤트를 무시하는 기능입니다.</p>\n<pre><code>const throttle = (func: Function, limit: number) => {\n  let lastCall = 0;\n\n  return (...args: any[]) => {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      func(...args);\n    }\n  };\n};\n</code></pre>\n<p>쓰로틀링에서도 동일하게 <code>lastCall</code> 변수를 계속 참조하고 있어서, <code>limit</code>이 지난 후 다시 실행해도 이전의 <code>lastCall</code> 값에 접근할 수 있는 것입니다.</p>\n<p>이렇듯 디바운스와 쓰로틀링은 클로저를 사용해서 구현 가능한데요. 확실히 이론적으로 외우는 것보다 실제 사용하는 코드로 접근하니 더 이해가 잘 되는 기분이네요.</p></div>",
    "date": "2025-02-04"
  },
  {
    "idx": 10,
    "title": "CORS오류를 피해 파일을 다운로드해 보자!",
    "summary": "Next.js API Routes와 Node.js 스트림을 사용해서 파일을 다운로드해 보자!",
    "content": "<div class=\"prose\"><p>이전 회사에서 외부 경로에 있는 파일 다운로드를 구현하는 일이 있었습니다. 유저가 버튼을 클릭하면 해당 유저가 찍은 사진과 비디오를 다운로드하는 간단한 흐름이었는데요. 처음엔 단순히 브라우저에서 <code>&lt;a&gt;</code> 태그를 사용하면 될 줄 알았지만 그게 아니었습니다.</p>\n<p>당시 파일들은 S3에 업로드되어 저장되고 있었고, 내부 사정상 브라우저에서 다운을 받기 위해 접근하면 CORS가 발생하는 상황이었습니다.</p>\n<p>백엔드 없이 프론트로만 기획이 되어 있어서 따로 API 요청이 불가했고, 결국 Next.js API Routes를 사용해서 파일을 다시 구성하는 방법으로 로직을 구현했습니다.</p>\n<p>큰 흐름은 아래와 같습니다.</p>\n<blockquote>\n<ol>\n<li>외부 파일이 존재하는지 확인</li>\n<li>유저가 다운로드 버튼 클릭</li>\n<li>Next.js API Routes를 사용해서 파일을 다시 전달</li>\n</ol>\n</blockquote>\n<p>순차적으로 하나씩 구성해보겠습니다.</p>\n<h2>1. 파일 존재여부 확인</h2>\n<p>파일의 경로는 URL 파라미터에 담겨 오는 형식이었습니다. 따라서 해당 경로에 파일이 존재하는지 여부를 확인하는 게 필수였는데요. HEAD 메소드를 사용해서 간단히 구현이 가능합니다.</p>\n<p>HEAD 메소드는 GET과 동일한 응답을 요청하지만 응답 본문을 포함하지 않습니다. 따라서 응답값의 reponse가 정상적이라면 파일이 존재한다고 판단할 수 있습니다.</p>\n<pre><code>const response = await fetch(url, { method: 'HEAD' });\n\nif (!response.ok) {\n  return res.status(404).json({ exists: false });\n}\n\nreturn res.status(200).json({ exists: true });\n</code></pre>\n<h2>2. 다운로드 버튼 클릭</h2>\n<p>유저가 다운로드 버튼을 클릭하면 정석적인 방법으로 <code>&lt;a&gt;</code> 태그를 생성 후 클릭하게 하는 방법으로 구현했습니다.</p>\n<pre><code>const downloadFile = async () => {\n  const response = await fetch(`/api/download-file?url=${encodeURIComponent(url)}&name=${encodeURIComponent(fileName)}`);\n\n  if (!response.ok) {\n    alert('Failed to download the file.');\n    return;\n  }\n\n  // 응답 데이터를 Blob으로 변환\n  const blob = await response.blob();\n\n  // Blob 데이터를 사용해 브라우저에서 파일 다운로드 트리거\n  const downloadUrl = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = downloadUrl;\n  a.download = fileName || 'downloaded-file';\n  a.click();\n\n  // 메모리 누수를 방지하기 위해 URL 객체 해제\n  URL.revokeObjectURL(downloadUrl);\n};\n</code></pre>\n<p>여기서 문제가 발생했는데요. 모바일 사파리 브라우저에서는 다운받은 사진과 비디오를 미리 볼 수 있는 기능이 있습니다. 하지만 <code>a.click()</code> 이후 바로 <code>URL.revokeObjectURL</code>을 사용하여 미리보기 가능한 URL을 제거하고 있었죠.</p>\n<p>유저가 파일을 여러 번 다운하는 경우는 거의 없다고 판단하여, 결국 <code>URL.revokeObjectURL</code>는 컴포넌트가 언마운트되는 경우에 작동하도록 수정했습니다.</p>\n<h2>3. API Routes 코드</h2>\n<p>파일을 다시 전달하는 코드는 Node.js의 스트림을 사용했습니다. 스트림은 데이터를 조각 단위로 처리할 수 있어 대용량 파일도 효율적으로 전송이 가능합니다.</p>\n<p>먼저 query로 받은 URL이 올바른 경로인지 확인합니다.</p>\n<pre><code>https.get(url, (externalRes) => {\n  if (externalRes.statusCode !== 200) {\n    return res.status(404).json({ error: '파일이 없습니다.' });\n  }\n});\n</code></pre>\n<p>그 다음 query로 받은 파일 이름을 설정하고 Content-Type과 같은 헤더를 설정합니다. 유저가 다운받는 파일은 변하지 않으므로 캐싱 기간을 1년으로 설정했습니다.</p>\n<pre><code>// 파일 이름 및 Content-Type 설정\nconst fileName = name && typeof name === 'string' ? name : url.split('/').pop() || 'downloaded-file';\nconst contentType = externalRes.headers['content-type'] || 'application/octet-stream';\n\n// 응답 헤더 설정\nres.setHeader('Content-Type', contentType);\nres.setHeader('Content-Disposition', `attachment; filename=\"${fileName}\"`);\nres.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n</code></pre>\n<p>이후 <code>pipe(res)</code>를 사용해 브라우저에 서버 응답 스트림과 클라이언트 응답 스트림을 연결시켜줍니다.</p>\n<pre><code>// 스트리밍 방식으로 외부 응답 데이터를 클라이언트에 전송\nexternalRes.pipe(res);\n</code></pre>\n<p>완성된 코드는 아래와 같습니다.</p>\n<pre><code>import type { NextApiRequest, NextApiResponse } from 'next';\nimport https from 'https';\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { url, name } = req.query;\n\n  // URL 유효성 검사\n  if (!url || typeof url !== 'string') {\n    return res.status(400).json({ error: '유효하지 않은 URL' });\n  }\n\n  try {\n    https.get(url, (externalRes) => {\n      if (externalRes.statusCode !== 200) {\n        return res.status(404).json({ error: '파일이 없습니다.' });\n      }\n\n      // 파일 이름 및 Content-Type 설정\n      const fileName = name && typeof name === 'string' ? name : url.split('/').pop() || 'downloaded-file';\n      const contentType = externalRes.headers['content-type'] || 'application/octet-stream';\n\n      // 응답 헤더 설정\n      res.setHeader('Content-Type', contentType);\n      res.setHeader('Content-Disposition', `attachment; filename=\"${fileName}\"`);\n      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n\n      // 스트리밍 방식으로 외부 응답 데이터를 클라이언트에 전송\n      externalRes.pipe(res);\n    }).on('error', (err) => {\n      console.error('Streaming error:', err);\n      res.status(500).json({ error: '파일 다운로드 실패 : Streaming' });\n    });\n  } catch (error) {\n    console.error('Download error:', error);\n    res.status(500).json({ error: '파일 다운로드 실패 : URL 다운로드' });\n  }\n}\n</code></pre>\n<p>생각보다 간단하면서도 복잡했는데요. Node.js의 스트림과 HEAD 메소드를 더 깊이 공부할 수 있는 좋은 경험이었습니다.</p></div>",
    "date": "2025-02-02"
  },
  {
    "idx": 9,
    "title": "SVG를 알아보자",
    "summary": "쉽지만 어려운 SVG",
    "content": "<div class=\"prose\">\n<p>이전 회사에서 도넛차트와 막대차트를 구현할 일이 있었습니다.\n처음엔 라이브러리를 사용하려고 했지만 요청받은 디자인을 반영할 수 없어서 SVG를 사용해서 직접 구현했었는데요.</p>\n<p>그 당시에는 만들기 급급해서 SVG의 자세한 내용을 분석하지 못했던 아쉬움이 있어서 이번 기회에 자세히 분석해보려 합니다.</p>\n<h1>SVG 기본 구조</h1>\n<p>SVG(Scalable Vector Graphics)는 웹에서 벡터 그래픽을 표현하기 위한 도구이며 SVG는 확대/축소 시에도 깨짐이 없습니다.\n기본적으로 XML 형식으로 작성되며, HTML 문서에서 <code>&lt;svg&gt;</code> 태그를 사용하여 정의할 수 있습니다.\nSVG 안에는 다양한 그래픽 요소를 추가할 수 있으며, 주요 태그로는 <code>&lt;circle&gt;</code>, <code>&lt;rect&gt;</code>, <code>&lt;line&gt;</code>, <code>&lt;path&gt;</code> 등이 있습니다.</p>\n<p>예시: 간단한 원 그리기</p>\n<svg width=\"200\" height=\"200\">\n  <circle cx=\"100\" cy=\"100\" r=\"80\" fill=\"skyblue\" stroke=\"black\" stroke-width=\"2\" />\n</svg>\n\n<p>출력 결과로는 파란색 내부와 검은색 외곽선을 가진 원이 그려집니다.</p>\n<h1>SVG 기본 요소와 속성</h1>\n<p>SVG에서는 다양한 도형을 그릴 수 있습니다.</p>\n<h3>1. <code>&lt;rect&gt;</code></h3>\n<p><code>&lt;rect/&gt;</code>를 사용하면 사각형을 만들 수 있습니다.</p>\n<pre><code>&lt;svg width=\"200\" height=\"200\"&gt;\n  &lt;rect x=\"20\" y=\"20\" width=\"150\" height=\"100\" fill=\"lightgreen\" stroke=\"black\" stroke-width=\"2\" rx=\"10\" ry=\"10\" /&gt;\n&lt;/svg&gt;\n</code></pre>\n<p>출력 결과:</p>\n<svg width=\"200\" height=\"200\">\n  <rect x=\"20\" y=\"20\" width=\"150\" height=\"100\" fill=\"lightgreen\" stroke=\"black\" stroke-width=\"2\" rx=\"10\" ry=\"10\" />\n</svg>\n\n<h3>2. <code>&lt;line&gt;</code></h3>\n<p><code>&lt;line&gt;</code>을 사용하면 선을 그릴 수 있습니다.</p>\n<pre><code>&lt;svg width=\"200\" height=\"200\"&gt;\n  &lt;line x1=\"10\" y1=\"10\" x2=\"190\" y2=\"190\" stroke=\"green\" stroke-width=\"4\" /&gt;\n&lt;/svg&gt;\n</code></pre>\n<p>출력 결과:</p>\n<svg width=\"200\" height=\"200\">\n  <line x1=\"10\" y1=\"10\" x2=\"190\" y2=\"190\" stroke=\"green\" stroke-width=\"4\" />\n</svg>\n\n<h3>3. <code>&lt;path&gt;</code></h3>\n<p><code>&lt;path&gt;</code>를 사용하면 사용자가 원하는 복잡한 도형을 그릴 수 있습니다.</p>\n<pre><code>&lt;svg width=\"200\" height=\"200\"&gt;\n  &lt;path d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" fill=\"none\" stroke=\"red\" stroke-width=\"2\" /&gt;\n&lt;/svg&gt;\n</code></pre>\n<p>출력 결과:</p>\n<svg width=\"200\" height=\"200\">\n  <path d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" fill=\"none\" stroke=\"red\" stroke-width=\"2\" />\n</svg>\n\n<p>주요 경로 명령어:</p>\n<ul>\n<li><strong>M x y</strong>: 시작 위치 이동 (Move to)</li>\n<li><strong>L x y</strong>: 직선 그리기 (Line to)</li>\n<li><strong>C x1 y1, x2 y2, x y</strong>: 큐빅 베지어 곡선 (두 개의 제어점과 끝점을 이용한 곡선)</li>\n<li><strong>S x2 y2, x y</strong>: 부드러운 곡선</li>\n</ul>\n<h3>4. 애니메이션</h3>\n<p>SVG에서는 stroke-dasharray와 stroke-dashoffset 속성을 사용해서 선이 그려지는 애니메이션을 표현할 수 있습니다.</p>\n<h4>1. stroke-dasharray</h4>\n<p>선을 점선으로 표현할 때, 선과 빈 공간의 길이를 지정합니다.\n예: <code>stroke-dasharray: 5, 10</code>은 선이 5px, 빈 공간이 10px로 반복됩니다.</p>\n<h4>2. stroke-dashoffset</h4>\n<p>선을 점차적으로 그려지는 효과를 구현할 수 있습니다.</p>\n<pre><code>&lt;svg width=\"200\" height=\"200\"&gt;\n  &lt;circle cx=\"100\" cy=\"100\" r=\"80\" fill=\"none\" stroke=\"red\" stroke-width=\"4\" stroke-dasharray=\"502\" stroke-dashoffset=\"502\"&gt;\n  &lt;style&gt;\n    circle {\n      animation: draw 3s linear infinite;\n    }\n    @keyframes draw {\n      from {\n        stroke-dashoffset: 502;\n      }\n      to {\n        stroke-dashoffset: 0;\n      }\n    }\n  &lt;/style&gt;\n&lt;/svg&gt;\n</code></pre>\n</div>",
    "date": "2025-02-01"
  },
  {
    "idx": 8,
    "title": "Next.js에서 pdf다운하기",
    "summary": "html2canvas와 jspdf 말고 puppeteer를 사용하자!",
    "content": "<div class=\"prose\">\n<p>그동안 PDF다운로드 기능은 html2canvas와 jspdf를 사용해서 클라이언트측에서 구현했지만,\n이번에 사이드 프로젝트를 하면서 서버에서 구현을 하고 싶어 ChatGPT도움을 받아 로직을 구성했습니다.</p>\n<p>기본적인 흐름은 다음과 같은데요</p>\n<ol>\n<li>프론트에서 HTML생성</li>\n<li>생성된 HTML을 서버로 전송</li>\n<li>서버에서 PDF파일 구성 후 프론트로 다시 전달</li>\n</ol>\n<p>위와 같은 흐름을 생각하고 GPT에게 요청하니 puppeteer 라이브러리를 추천해주었습니다.</p>\n<h3>puppeteer란?</h3>\n<p>puppeteer는 Headless Chrome 또는 Chromium 브라우저를 제어하기 위한 Node.js 라이브러리로 구글이 만들었습니다.\n주로 웹 스크래핑 혹은 테스트에 사용한다고 하는데 pdf생성해도 딱 맞아서 이번에 사용해보기로 결정했습니다.</p>\n<h3>클라이언트 로직 구성</h3>\n<p>클라이언트 측 로직은 간단한데요,\npdf로 만들기 원하는 HTML을 서버로 전송 후,\nresponse를 a태그를 생성해서 다운로르 하면 끝입니다.</p>\n<pre><code>const handleDownloadPDF = async () =&gt; {\n    const input = document.getElementById(\"pdf-content\");\n    if (input) {\n      const htmlContent = input.outerHTML;\n\n      const response = await fetch(\"/api/pdf\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ htmlContent }),\n      });\n\n      if (response.ok) {\n        const blob = await response.blob();\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"download.pdf\";\n        document.body.appendChild(a);\n        a.click();\n        a.remove();\n      } else {\n        console.error(\"Error generating PDF\");\n      }\n    }\n  };\n</code></pre>\n<h3>서버 로직 구성</h3>\n<p>서버는 조금 복잡합니다.\n(사실 next.js 15버전으로 처음 구현하느라 공식문서를 참고하는 시간이 더 길었네요)</p>\n<p>전체코드는 아래와 같습니다.</p>\n<pre><code>import { NextRequest, NextResponse } from \"next/server\";\nimport puppeteer from \"puppeteer\";\n\n// 응답을 캐싱하지 않고 매번 재응답\nexport const dynamic = \"force-static\";\n\nexport async function POST(req: NextRequest) {\n  const { htmlContent } = await req.json();\n  if (!htmlContent) {\n    return NextResponse.json(\n      { message: \"HTML content is required\" },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const browser = await puppeteer.launch({\n      headless: true,\n      args: [\"--no-sandbox\", \"--disable-setuid-sandbox\"],\n    });\n    const page = await browser.newPage();\n\n    // HTML 콘텐츠 설정\n    await page.setContent(htmlContent, { waitUntil: \"load\" });\n\n    // PDF 생성\n    const pdfBuffer = await page.pdf({\n      format: \"A4\",\n      printBackground: true,\n      margin: { top: \"20mm\", bottom: \"20mm\", left: \"10mm\", right: \"10mm\" },\n    });\n\n    await browser.close();\n\n    // PDF 반환\n    const response = new NextResponse(pdfBuffer, {\n      headers: {\n        \"Content-Type\": \"application/pdf\",\n        \"Content-Disposition\": \"attachment; filename=generated.pdf\",\n      },\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"Error generating PDF:\", error);\n    return NextResponse.json(\n      { message: \"Failed to generate PDF\" },\n      { status: 500 }\n    );\n  }\n}\n</code></pre>\n<p>위 코드는 언핏보면 잘 동작하는 것 같지만 두가지 문제가 있었어요</p>\n<h2>이미지가 안 보이네?</h2>\n<p>위 코드를 실행하니 이미지가 모두 깨져서 출력되는 문제가 발생했습니다.\n우선 프론트 로직 구조상 이미지는 모두 내부파일을 사용하고 있었습니다.\n그래서 경로는 \"/icons/testImage.svg\"와 같이 상대경로 되어있었죠.\n여기서 문제가 발생했습니다.</p>\n<p><code>&lt;img src=\"/techstack/back/nestjs.svg\"&gt;</code>\n서버로 넘겨주는 HTML의 img태그의 src경로가 상대경로로 되어있어 이미지 인식을 못했던겁니다.\n즉, 서버에서 이미지 경로를 절대경로로 변경해야 하는거죠</p>\n<p>htmlContent변수를 let으로 수정하고\n다음과 같이 상대경로를 절대경로로 변경해주면 됩니다.</p>\n<pre><code>  const baseUrl = \"http://서버주소\"; //\n  htmlContent = htmlContent.replace(/src=\"\\/(.*?)\"/g, `src=\"${baseUrl}/$1\"`);\n</code></pre>\n<h2>CSS와 폰트 어디갔니?</h2>\n<p>해당 프로젝트는 tailwind를 사용하고 있었는데요.\n이 때문에 pdf를 출력하면 CSS가 모두 초기화되는 현상이 나타났습니다.\n서버에선 tailwind가 없어서 className을 인식하지 못해서 당연한 현상이였죠</p>\n<p>수정은 간단합니다.\ntawilwind CDN을 HTML에 추가해주고,\n원하는 폰트 또한 스타일에 추가시켜주면 됩니다.</p>\n<pre><code>// Tailwind CDN 추가\n  const tailwindCDN = `\n   &lt;link href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css\" rel=\"stylesheet\"&gt;\n   &lt;link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap\" rel=\"stylesheet\"&gt;\n   &lt;style&gt;\n     body { font-family: 'Inter', sans-serif; }\n   &lt;/style&gt;\n `;\n\n  htmlContent = `\n   &lt;!DOCTYPE html&gt;\n   &lt;html lang=\"en\"&gt;\n     &lt;head&gt;\n       &lt;meta charset=\"UTF-8\"&gt;\n       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n       ${tailwindCDN}\n     &lt;/head&gt;\n     &lt;body&gt;\n       ${htmlContent}\n     &lt;/body&gt;\n   &lt;/html&gt;\n `;\n</code></pre>\n<p>이로써 서버측에서 pdf를 생성하는 로직을 구현 완료했습니다.\n아직 다듬을 부분이 더 있지만, 이는 추후 다시 수정해봐야겠네요.</p>\n</div>",
    "date": "2025-01-16"
  },
  {
    "idx": 7,
    "title": "canvas.toBlob이 IOS에서 null을 반환 받는 경우",
    "summary": "어렵고 어려운 크로스 브라우징🤣",
    "content": "<div class=\"prose\">\n<p>회사에서 react-easy-crop 라이브러리와 canvas API를 사용하다가 IOS에서만 zoom이 1이하인 경우에 canvas.toBlob이 null을 반환받는 현상을 발견했다.</p>\n<p>이런저런 방법을 찾아보다 gpt 친구에게 물어보니 ios에선 메모리 제한에 걸려  null을 반환받을 수 있다는 답변을 받고 캔버스 크기를 확인해 보니,\n특정 zoom 이하인 경우에는 캔버스 크기가 무지막지하게 커져있었다.</p>\n<blockquote>\n<p><strong>GPT답변</strong>\niOS에서 매우 높은 해상도나 대형 캔버스를 사용할 경우 메모리 제한으로 인해 빈 이미지를 생성할 수 있습니다. 이를 해결하려면 캔버스 크기를 줄이거나, 이미지 해상도를 낮추어 메모리 사용량을 줄이는 것이 좋습니다.</p>\n</blockquote>\n<p>해결법은 상당히 간단하다.\n이미지 해상도를 낮추거나 캔버스 크기를 줄이면된다.\n우리 서비스는 이미지 해상도가 중요하니\n캔버스 크기를 zoom만큼 줄이는 방법으로 수정했다.</p>\n<pre><code>const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\nnewImage.src = imagePath;\nnewImage.onload = () =&gt; {\n  const scalefactor = Math.min(zoom, 1);\n  \n  canvas.width = width * scalefactor;\n  canvas.height = height * scalefactor;\n  \n  ctx.scale(scalefactor, scalefactor);\n  ctx.drawImage(newImage, 0, 0);\n\n  canvas.toBlob((blob) =&gt; {\n    ...로직\n  }, 'image/png');\n};\n</code></pre>\n</div>",
    "date": "2024-11-12"
  },
  {
    "idx": 6,
    "title": "visual studio code 터미널 프로필 꾸미기",
    "summary": "터미널 꾸미기 어렵지~ 않아요",
    "content": "<div class=\"prose\">\n<h1>이제는 테스트 코드를 작성할 때</h1>\n<p>작년 5월 이직 후, 회사에서 담당한 프로젝트를 지속적으로 리팩토링 및 기능 추가를 진행하고 있었다.</p>\n<p>사실 개발을 진행하면서 테스트코드 없이 로직검증을 위해 생각보다 많은 시간이 소요되는걸 느끼고 테스트 코드의 필요성을 깨달았다.\n(특정시간에 오픈되는 UI, 가격계산로직 등등... 테스트코드 없이 검증하려니 비효율적으로 낭비되는 시간과 노력이 많이 발견됨)</p>\n<p>그러다 다른 팀의 신규 프로젝트 준비로 잠시 여유가 생겨 미루고 미뤄뒀던 테스트 코드를 도입하기로 결정했다.</p>\n\n<h1>Why Vitest</h1>\n<p>처음엔 jest를 사용하려 했지만 최종적으론 vitest를 사용하기로 했다.\njest에 비해 초기설정도 간단하며 테스트 속도도 더 빠른 것으로 판단되어 vitest를 사용하지 않을 이유가 없었다.</p>\n<p>또한, <a href=\"https://www.npmjs.com/package/@vitest/ui\">vitest/ui</a> 라이브러리를 통한 GUI도 깔끔하여 개발 효율이 더 증가해서 만족스러웠다.</p>\n<p>비록 아직 Vitest 사용자가 많지 않아 레퍼런스가 적지만,\njest와 90% 이상(주관적 수치입니다)유사하여 막히는 부분이 있으면 ChatGPT의 도움으로도 충분히 커버가 가능하다.</p>\n\n<h1>Test파일은 어디에 두어야 하나</h1>\n<p>처음 테스트 코드를 작성하면서 가장 큰 고민은 테스트 코드의 위치였다.\n처음엔 __tests__ 폴더를 생성하여 하위 폴더에 작성하였다.</p>\n<p>그러나 이 방식은 테스트 코드와 파일들의 위치가 너무 멀어 매번 스크롤을 해주고,\n원하는 테스트 파일을 찾는데 시간도 걸리는 문제도 있다는 단점이 있었다.</p>\n<p>결국 개발 효율을 위해 테스트 관련 유틸 및 설정파일은 __tests__ 폴더에 두고, 나머지 파일들은 테스트대상 파일 바로 아래에 두는 방식으로 변경했다.</p>\n\n<h1>트러블슈팅</h1>\n<h2>next/Image src문제</h2>\n<p>next/image컴포넌트의 src는 보통 \"/_next/image?url=~~\"와 같은 형태로 구성된다.</p>\n<p>만약 이미지 경로가 \"testImage.com\"이라고 가정하면\nnext/image를 통한 src는 \"/_next/image?url=testImage.com&w=640&q=50\"과 같은 형태이므로\n<code>expect().toHaveAttribute('src',\"testImage.com\")</code>는 틀린 테스트케이스가 된다.</p>\n<p>이 문제는 next/image컴포넌트 자체를 mocking하여 일반 img태그를 변환시키는 방법으로 해결했다.</p>\n<pre><code>import { vi } from 'vitest';\n\nconst mockNextImage = () => {\n  vi.mock('next/image', () => ({\n    __esModule: true,\n    default: (\n      props: React.DetailedHTMLProps<\n        React.ImgHTMLAttributes<HTMLImageElement>,\n        HTMLImageElement\n      >,\n    ) => {\n      return <img alt={props.alt} {...props} />;\n    },\n  }));\n};\n\nexport { mockNextImage };\n</code></pre>\n\n<h2>Next.js Dynamic Import</h2>\n<p>특정 컴포넌트는 nextjs에서 제공하는 dynamic을 사용해서 import하고 있었다.\n이러한 컴포넌트들은 vitest 테스트 환경에선 load되지 않는 문제가 있다.</p>\n<p>해당 문제는 next/dynamic자체를 mocking하여 해결 가능하다.</p>\n<pre><code>vi.mock('next/dynamic', async () => {\n  const dynamicModule: any = await vi.importActual('next/dynamic');\n  return {\n    default: (loader: any) => {\n      const dynamicActualComp = dynamicModule.default;\n      const RequiredComponent = dynamicActualComp(() =>\n        loader().then((mod: any) => mod.default || mod),\n      );\n\n      // for debugging\n      if (RequiredComponent?.render?.displayName) {\n        RequiredComponent.render.displayName = loader.toString();\n      }\n\n      RequiredComponent.preload\n        ? RequiredComponent.preload()\n        : RequiredComponent.render.preload();\n\n      return RequiredComponent;\n    },\n  };\n});\n</code></pre>\n</div>",
    "date": "2024-03-04"
  },
  {
    "idx": 5,
    "title": "사내 테스트코드 도입기",
    "summary": "나도 드디어 도전한다 TDD!",
    "content": "<div class=\"prose\">\n<h1>이제는 테스트 코드를 작성할 때</h1>\n<p>작년 5월 이직 후, 회사에서 담당한 프로젝트를 지속적으로 리팩토링 및 기능 추가를 진행하고 있었다.</p>\n<p>사실 개발을 진행하면서 테스트코드 없이 로직검증을 위해 생각보다 많은 시간이 소요되는걸 느끼고 테스트 코드의 필요성을 깨달았다.\n(특정시간에 오픈되는 UI, 가격계산로직 등등... 테스트코드 없이 검증하려니 비효율적으로 낭비되는 시간과 노력이 많이 발견됨)</p>\n<p>그러다 다른 팀의 신규 프로젝트 준비로 잠시 여유가 생겨 미루고 미뤄뒀던 테스트 코드를 도입하기로 결정했다.</p>\n\n<h1>Why Vitest</h1>\n<p>처음엔 jest를 사용하려 했지만 최종적으론 vitest를 사용하기로 했다.\njest에 비해 초기설정도 간단하며 테스트 속도도 더 빠른 것으로 판단되어 vitest를 사용하지 않을 이유가 없었다.</p>\n<p>또한, <a href=\"https://www.npmjs.com/package/@vitest/ui\">vitest/ui</a> 라이브러리를 통한 GUI도 깔끔하여 개발 효율이 더 증가해서 만족스러웠다.</p>\n<p>비록 아직 Vitest 사용자가 많지 않아 레퍼런스가 적지만,\njest와 90% 이상(주관적 수치입니다)유사하여 막히는 부분이 있으면 ChatGPT의 도움으로도 충분히 커버가 가능하다.</p>\n\n<h1>Test파일은 어디에 두어야 하나</h1>\n<p>처음 테스트 코드를 작성하면서 가장 큰 고민은 테스트 코드의 위치였다.\n처음엔 __tests__ 폴더를 생성하여 하위 폴더에 작성하였다.</p>\n<p>그러나 이 방식은 테스트 코드와 파일들의 위치가 너무 멀어 매번 스크롤을 해주고,\n원하는 테스트 파일을 찾는데 시간도 걸리는 문제도 있다는 단점이 있었다.</p>\n<p>결국 개발 효율을 위해 테스트 관련 유틸 및 설정파일은 __tests__ 폴더에 두고, 나머지 파일들은 테스트대상 파일 바로 아래에 두는 방식으로 변경했다.</p>\n\n<h1>트러블슈팅</h1>\n<h2>next/Image src문제</h2>\n<p>next/image컴포넌트의 src는 보통 \"/_next/image?url=~~\"와 같은 형태로 구성된다.</p>\n<p>만약 이미지 경로가 \"testImage.com\"이라고 가정하면\nnext/image를 통한 src는 \"/_next/image?url=testImage.com&w=640&q=50\"과 같은 형태이므로\n<code>expect().toHaveAttribute('src',\"testImage.com\")</code>는 틀린 테스트케이스가 된다.</p>\n<p>이 문제는 next/image컴포넌트 자체를 mocking하여 일반 img태그를 변환시키는 방법으로 해결했다.</p>\n<pre><code>import { vi } from 'vitest';\n\nconst mockNextImage = () => {\n  vi.mock('next/image', () => ({\n    __esModule: true,\n    default: (\n      props: React.DetailedHTMLProps<\n        React.ImgHTMLAttributes<HTMLImageElement>,\n        HTMLImageElement\n      >,\n    ) => {\n      return <img alt={props.alt} {...props} />;\n    },\n  }));\n};\n\nexport { mockNextImage };\n</code></pre>\n\n<h2>Next.js Dynamic Import</h2>\n<p>특정 컴포넌트는 nextjs에서 제공하는 dynamic을 사용해서 import하고 있었다.\n이러한 컴포넌트들은 vitest 테스트 환경에선 load되지 않는 문제가 있다.</p>\n<p>해당 문제는 next/dynamic자체를 mocking하여 해결 가능하다.</p>\n<pre><code>vi.mock('next/dynamic', async () => {\n  const dynamicModule: any = await vi.importActual('next/dynamic');\n  return {\n    default: (loader: any) => {\n      const dynamicActualComp = dynamicModule.default;\n      const RequiredComponent = dynamicActualComp(() =>\n        loader().then((mod: any) => mod.default || mod),\n      );\n\n      // for debugging\n      if (RequiredComponent?.render?.displayName) {\n        RequiredComponent.render.displayName = loader.toString();\n      }\n\n      RequiredComponent.preload\n        ? RequiredComponent.preload()\n        : RequiredComponent.render.preload();\n\n      return RequiredComponent;\n    },\n  };\n});\n</code></pre>\n</div>",
    "date": "2024-01-05"
  },
  {
    "idx": 4,
    "title": "HEIF형식 이미지 업로드 대응",
    "summary": "최신 이미지 포맷인 HEIF를 아시나요?",
    "content": "<div class=\"prose\"><h1>어느날...</h1>\n<p>어느날 heic(heif) 이미지 파일이 업로드가 되지 않는다는 문의가 왔다.\nheif형식이 무엇인지 찾아보니 고효율 이미지 파일 포맷(High Efficiency Image Format)으로 동일한 크기의 jpeg보다 2배나 더 많은 정보를 저장할 수 있으므로 화질이 더 좋다고 한다.</p>\n<p>그러나 2023년 현재에도 아직 호환성이 떨어지며 웹브라우저에서는 지원하지 않고 있다.\nIOS의 경우에는 heic파일을 업로드할 때 자체적으로 jpg로 변환시켜주므로 큰 문제는 없지만,\nAOS및 브러우저에서는 직접 jpg로 변환하는 로직을 구성해줘야 heic이미지 업로드가 대응된다.</p>\n<p>따라서 heif형식을 jpg로 변경하는 로직을 구성해서 해당 이슈를 해결하기로 결정했다.</p>\n<h1>heic2any 라이브러리 도입</h1>\n<p>처음에는 단순히 jpg타입을 지정해서 blob으로 변환 후 다시 파일로 만들면 되지 않을까 싶었지만 확장자만 변경되고 문서유형은 변경되지 않아서 실패했다.</p>\n<pre><code>const blob = new Blob([innerFile[1]], {\n  type: 'image/jpeg',\n});\n\nconst heifToPngFile = new File(\n  [blob],\n  innerFile[1].name\n    .replaceAll('.heif', '.jpg')\n    .replaceAll('.heic', '.jpg')\n    .replaceAll('.HEIC', '.jpg')\n    .replaceAll('.HEIF', '.jpg'),\n  {\n    type: 'image/jpeg',\n  },\n);\n</code></pre>\n<p>방법을 찾다가 CTO님이 추천해주신 heic2any를 사용하기로 결정했다\n구글링 결과, 해당 라이브러리를 사용해서 heif파일을 변환하는 사례가 몇몇 있어서 해당 사례들을 참고해서 로직을 구현했다.</p>\n<pre><code>const blob = new Blob([files[0]]);\nconst transBlob = await heic2any({\n  blob,\n  quality: 0.1,\n  toType: 'image/jpeg',\n});\nconst trnasFile = new File(\n  [transBlob],\n  files[0].name\n    .replaceAll('.heif', '.jpg')\n    .replaceAll('.heic', '.jpg')\n    .replaceAll('.HEIC', '.jpg')\n    .replaceAll('.HEIF', '.jpg'),\n  {\n    type: 'image/jpeg',\n    lastModified: new Date().getTime(),\n  },\n);\n</code></pre>\n<p>위의 로직을 사용해서 테스트해 보니 잘 작동하여 안심을 했지만....\n뜻밖의 변수가 발생했다.</p>\n<h1>AOS버전에 따른 차이점</h1>\n<p>회사에서 안드로이드폰으로 테스트 중, 안드로이드 8 버전에서는 이미지가 업로드 되지 않는 문제가 발견되어 디버깅을 진행하고 문제점을 발견했다.</p>\n<p>특정 안드로이드 버전에서는 Heif 형식을 지원하지 않으므로 해당 파일을 업로드할 때, 파일의 타입이 정해지지 않고 비어있는 상태로 업로드되어 서버 측에서 해당 파일 업로드를 하지 않았던 것이다.</p>\n<p>안드로이드 공식 홈페이지에 따르면 안드로이드 10버전부터 Heif 형식을 지원해준다고 한다. <a href=\"https://source.android.com/docs/core/camera/heif?hl=ko\">안드로이드 공식 홈페이지</a></p>\n<p>따라서 기존 로직에 안드로이드 버전10버전 미만에서는 blob으로 변경후, 타입을 지정해주는 방법으로 문제를 해결했다.</p>\n<pre><code>const userAgent = navigator.userAgent.toLowerCase();\nconst androidIndex = userAgent.indexOf('android');\nconst androidVer = Number(\n  userAgent\n    .substring(androidIndex + 8)\n    .split(';')[0]\n    .split('.')[0],\n);\n\nif (androidVer &lt; 10) {\n  const blob = new Blob([innerFile[1]], {\n    type: 'image/jpeg',\n  });\n\n  const heifToPngFile = new File(\n    [blob],\n    innerFile[1].name\n      .replaceAll('.heif', '.jpg')\n      .replaceAll('.heic', '.jpg')\n      .replaceAll('.HEIC', '.jpg')\n      .replaceAll('.HEIF', '.jpg'),\n    {\n      type: 'image/jpeg',\n    },\n  );\n}\n</code></pre>\n<p>#개선할 점\nheic2any라이브러리를 사용해서 문제를 해결할 수 있었지만....\n해당 라이브러리 번들 사이즈를 확인하니 너무 무지막지한 용량을 가지고 있었다.\n<img alt=\"\" src=\"https://velog.velcdn.com/images/yung315/post/2cbc8bd8-dfc2-48f8-8013-e936f9f650b2/image.png\"></p>\n<p>이러한 사이즈 문제는 깃헙 이슈에도 이미 올라와 있었는데,\n개발자의 답변으로는 heif 변환시 사용하는 libheif 라이브러리 용량 자체가 크므로 해결방법이 없다고한다. <a href=\"https://github.com/alexcorvi/heic2any/issues/35\">깃헙 이슈</a></p>\n<p>결국 라이브러리를 사용하지않거나 다른 라이브러리가 있는지 찾을 필요가 있어보인다.</p></div>",
    "date": "2023-10-10"
  },
  {
    "idx": 3,
    "title": "ReactDOMClient.hydrateRoot사용 시, hydration 오류",
    "summary": "next.js 및 react에서 자주 발생하는 hydration오류, 넌 뭐니?",
    "content": "<div class=\"prose\"><p>회사에서 담당한 프로젝트를 리팩토링 하던 중, dangerouslySetInnerHTML을 사용한 컴포넌트에서 hydration 오류가 발생하여 이를 해결한 경험을 남겨본다.</p>\n<h2>우선, hydration이란?</h2>\n<p>hydration은 서버에서 만들어진 HTML이 클라이어트단으로 넘어온 뒤,\nHTML과 JS를 결합하는 과정이라 생각하면 된다.\n이 과정에서 서버에서 생성된 HTML과 브라우저에서 처음 렌더링 되는 HTML은 동일해야하며, 만약 동일하지 않다면 hydration오류가 발생한다.</p>\n<h2>그래서 문제가 뭔데?</h2>\n<p>우선 해당 컴포넌트는 아래의 역할을 하고 있다.</p>\n<blockquote>\n<ol>\n<li>Admin에서 HTML을 문자열 형태로 전송</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>해당 HTML중 dataset.type이 설정된 태그는 클라이언트측에서 CSS수정</li>\n<li>수정된 CSS를 포함해서 dangerouslySetInnerHTML을 사용하여 렌더링</li>\n</ol>\n<p>기존의 로직은 아래와 같이 ReactDOMClient.hydrateRoot을 사용하고 있었다.</p>\n<pre><code>useEffect(()=&gt;{\n\tconst target: NodeListOf&lt;HTMLElement&gt; = document.querySelectorAll('.target_class_name');\n    \n    target.forEach((dom) =&gt; {\n      if (dom.dataset.type === '특정타입') {\n        ReactDOMClient.hydrateRoot(\n          dom,\n        \t\t&lt;CSSModifyComponent /&gt;\n        );\n\t}\n},[])\n</code></pre>\n<p>해당 코드에서 hydration오류가 발생한 이유는 ReactDOMClient.hydrateRoot을 사용했기 때문이다.</p>\n<p>React에서 설명하는 ReactDOMClient.hydrateRoot는 다음과 같다</p>\n<blockquote>\n<p>createRoot()과 동일하지만, HTML 컨텐츠가 ReactDOMServer로 렌더링된 컨테이너를 hydrate 할 때 사용합니다. React는 기존 마크업에 이벤트 리스너를 연결하려 시도할 것입니다.</p>\n</blockquote>\n<p>즉, hydrateRoot는 새로 렌더링된 결과물을 만드는것이 아닌 미리 만들어진 결과물에 이벤트 리스너만 부착하는것이다.</p>\n<p>따라서 새로운 HTML을 렌더링하기 위해서 hydrateRoot를 사용하는것은 적절하지 않으므로 오류가 발생했던것이다.</p>\n<p>해당 오류를 해결법은 간단한데,\nReactDOMClient.createRoot를 사용하여 클라이언트측에서 HTML을 다시 구성해주면 된다.</p>\n<pre><code>useEffect(()=&gt;{\n\tconst target: NodeListOf&lt;HTMLElement&gt; = document.querySelectorAll('.target_class_name');\n    \n    target.forEach((dom) =&gt; {\n      if (dom.dataset.type === '특정타입') {\n      const targetDom = ReactDOMClient.createRoot(dom);\n      targetDom.render(\n        ReactDOMClient.hydrateRoot(\n          dom,\n        \t\t&lt;CSSModifyComponent /&gt;\n        ))\n\t}\n},[])\n</code></pre></div>",
    "date": "2023-08-10"
  },
  {
    "idx": 2,
    "title": "Git - remote: The project you were looking for could not be found or you don't have permission to view it. ",
    "summary": "원격저장소에서 발생하는 Git 오류룰 해결 과정",
    "content": "<div class=\"prose\"><p>회사에서 운영중인 프로젝트를 급하게 수정 후 배포할 일이 생겼다.\n작업을 다 끝내고 push까지 완료해서 일이 끝났다고 생각했지만 갑자기 뜬 아래의 gitlab CI/CD오류...</p>\n<blockquote>\n<p>remote: The project you were looking for could not be found or you don't have permission to view it.\nfatal: repository '저장소주소' not found</p>\n</blockquote>\n<p>처음엔 로컬환경 문제인가 싶어서 급하게 로컬 git origin주소를 변경했지만 해결 실패...!\n이후 gitlab runner문제라 생각되어 runner재등록을 진행했지만 또 실패 !</p>\n<p>몇시간 고민 후 해결방법을 찾았는데 원인은 생각보다 간단했다.</p>\n<p>바로 ec2 git origin을 변경해주면 되는것 !\n(배포환경은 ec2 + gilab CI/CD)</p>\n<p>ec2로 접속후 <strong>git remote set-url origin</strong> 명령어를 사용하여 수정해주니 문제해결 !</p>\n<pre><code>수정 전 git origin\nhttps://gitlab.com/프로젝트/프로젝트_명.git\n\n수정 후 git origin\nhttps://깃랩아이디:비밀번호@gitlab.com/프로젝트/프로젝트명.git\n</code></pre></div>",
    "date": "2023-07-20"
  },
  {
    "idx": 1,
    "title": "next/image - Error handling",
    "summary": "next/image 컴포넌트로 이미지 에러를 핸들링해 보자!",
    "content": "<div class=\"prose\"><p>회사에서 리펙토링을 진행하던 중, 아래의 이슈사항을 발견했다.</p>\n<blockquote>\n<ol>\n<li>API 호출로 이미지 경로를 받아오고, 해당 이미지는 next/image로 렌더링</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>이미지 경로가 null인 경우에는 defaultImage를 렌더링</li>\n<li>이미지 경로를 받아오지만, 해당 경로의 이미지에 문제가 있는 경우에는 defaultImage를 보여주지 못하는 문제가 발생 !!</li>\n</ol>\n<pre><code>&lt;Image \n    alt={\"이미지\"} \n    src={imgUrl ? imgUrl : DEFAULT_IMG_URL} \n    width={width} \n    height={height} \n/&gt;\n</code></pre>\n<p>기존 코드는 위와 같았다. 기존 코드는 imgUrl이 null이 아닌 경우만 체크하고 있기 때문에 이미지 경로가 문제가 있는 경우의 예외처리를 진행하지 못하고 있었다.</p>\n<p>예를 들어 서버에서 보내준 \"admin/img1\" 이미지가 문제가 발생해 404를 반환받는 경우, 기존 코드는 imgUrl이 null이 아니므로 defaultImg가 렌더링되지 않는 것이다.</p>\n<p>위와 같은 문제를 방지하기 위해서 next/image의 onError를 활용해 커스텀 컴포넌트를 생성하였다.</p>\n<pre><code>interface ImageProps {\n    alt: string;\n    src: string;\n    width: number;\n    height: number;\n}\n\nexport default function ImageWithFallback({ alt, src, height, width }: ImageProps) {\n    const [isImgError, setIsImgError] = useState&lt;boolean&gt;(false);\n\n    return (\n        &lt;Image \n            alt={alt} \n            src={isImgError ? DEFAULT_PROFILE_IMG_URL : src} \n            width={width} \n            height={height} \n            onError={() => setIsImgError(true)} \n        /&gt;\n    );\n}\n</code></pre>\n<p>위와 같이 onError를 활용해 이미지 load에 실패하는 경우에는 isImgError가 true로 변경되면서 defaultImg를 보여주는 방식으로 리팩토링을 진행했다.</p></div>",
    "date": "2023-07-03"
  }
]
